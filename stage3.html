<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Eamonn Laffey's Learning Portforlio</title>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    <body>
        <div class="banner"><a href="index.html">COMP3500 Learning Portfolio</a></div>
        <div class="container">
            <ul class="menu">
                <li><a class="menu-item1" href="week1.html">WEEK 1</a></li>
                <li><a class="menu-item2" href="week2.html">WEEK 2</a></li>
                <li><a class="menu-item3" href="week3.html">WEEK 3</a></li>
                <li><a class="menu-item4" href="week4.html">WEEK 4</a></li>
                <li><a class="menu-item5" href="week5.html">WEEK 5</a></li>
                <li><a class="menu-item6" href="week6.html">WEEK 6</a></li>
                <li><a class="menu-item7" href="week7.html">WEEK 7</a></li>
                <li><a class="menu-items2" href="stage2.html">STAGE 2</a></li>
                <li><a class="menu-item6" href="stage3.html">STAGE 3</a></li>

            </ul>
            <div class="content">
                <h1 class="stage2">Stage 3</h1>
                <p>One issue that is very common among software engineering projects is that of overestimating how much work tasks will take and similarly overestimating how quickly it will take to complete tasks. This often leads to software projects running overtime and over budget. Despite being well aware of how inexperience as a team and within the context of larger software projects in general we fell for the common mistake and as consequence were not able to complete as much as we would have liked by the end of the project.</p>
                <p>During the initial planning phase we absolutely considered that this may be a problem and adjusted the games scope to account for this, however, in retrospect not enough. Other non-technical issues such as team and time management also problems with how much of the project we were able to complete.</p>
                <p>The issue of why the project estimates were not correct went further than just the issue of not being able to program as fast as we expected or there being more work to do than anticipates, however, that was certainly part of the reason. One major issue that slowed down progress was that of dividing up work in an efficient way so that we could all work on the project and progress the project. Although, dividing up the work was not too difficult, doing it so that we would all get to work on things that we are best suited on was more difficult. Another major issue was the fact that in tandem to developing a game we made the decision to develop an engine as well. The game engine was technically more difficult and required a lot of work, furthermore, due to the fact the game requires the engine to be at a reasonable state for any progress to be made on the game itself, the engine proved to be a major bottleneck in the development of the project. Another issue was due to the technical difficulty and fundamental nature of game engines is was not possible for each group member to work on the engine at the same time.</p>
                <p>However, I felt, personally, that focusing on the engine allowed me to learn a great deal about how games work under the hood. It also allowed the game to run very quickly. Since we focused on mobile devices, high performance was very important to achieve consistent 60 frames per second on older devices. Another benefit was that the engine was tailor made for our specific game. This allowed to be much simpler and easier for our group to understand than existing traditional engines  that contain many features, most not relevant to our specific use case. More still, creating our own engine gave us to opportunity to extend it as was suited to us. Many existing engines are open source and provide the ability to this as well, however, since they are so large and complicated as well as the fact of our group being inherently unfamiliar with their inner workings would make it prohibitively difficult to do this. Also being able to extend features onto the engine allowed us to experiment with new ideas.</p>
                <p>One thing I have found difficult is balancing between high quality code and getting things done quickly. I have found that depending on the particular feature, the quick and dirty solution may be the most appropriate, where as some parts of the code base, continuously need to be improved and are often used by many members of the group. These important sections of the project are best suited to a careful and deliberate design process. Adapting a quick and dirty solution for these parts, may be quicker in the short term but in the longer run it becomes unmanageable. Anticipating which parts of the code should are best suited for either strategy is something I have found is mostly a skill that is learnt through experience. I don't feel an analytical process can be used to help with this. During the project when designing the collision detection system I felt that it is a very important and integral part of the game, and thus put a lot of effort into ensuring it would run optimally and was designed as best as possible. Although, my initial reasoning was sound — collision detection is indeed very important to a game and remains so with our game, what I failed to realise was how drastically our needs would differ from what I first thought when designing the collision detection. As the game progressed, the requirements of the collision detection similarly progressed. This required the work I undertook to be thrown out and replaced, largely rendering the careful design and optimisations I worked on to be somewhat wasted.</p>
                <p>Donald Knuth is credited with saying: “We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%” I feel that this has been somewhat of an issue throughout the project, however, many of the optimisations made during the beginning of the project, particularly those related to the engine were not wasted. For instance, I was aware that in video games, much of the processing effort is spent on rendering. As result I put a great deal of effort in optimising rendering engine. However, since the rendering engine matured as our requirements changed, some of the optimisations became cumbersome when changing the system itself. As Donald Knuth mentions: only 3% of the program is performance critical and optimisation should focus on that 3%. I have found what I intuitively feel would be a performance critical section of the game, is often not is really as critical as I might have first thought. Thus, making the optimal use of tooling such as profilers and debuggers as been immensely helpful in improving the code base as well as fixing bugs. However, one thing that has been a difficult balance is that the performance critical sections of code often become the sections of code that are most heavily used and optimisations often come at the sacrifice of readability and manageability.</p>
            </div>
        </div>
    </body>
</html>