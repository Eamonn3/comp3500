<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Eamonn Laffey's Learning Portforlio</title>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    <body>
        <div class="banner"><a href="index.html">COMP3500 Learning Portfolio</a></div>
        <div class="container">
            <ul class="menu">
                <li><a class="menu-item1" href="week1.html">WEEK 1</a></li>
                <li><a class="menu-item2" href="week2.html">WEEK 2</a></li>
                <li><a class="menu-item3" href="week3.html">WEEK 3</a></li>
                <li><a class="menu-item4" href="week4.html">WEEK 4</a></li>
                <li><a class="menu-item5" href="week5.html">WEEK 5</a></li>
                <li><a class="menu-item6" href="week6.html">WEEK 6</a></li>
                <li><a class="menu-item7" href="week7.html">WEEK 7</a></li>
                <li><a class="menu-items2" href="stage2.html">STAGE 2</a></li>
            </ul>
            <div class="content">
                <h1 class="stage2">Stage 2</h1>
                <p>As the project develops and becomes more substantial, it becomes increasingly more important that a solid ground work is laid down to build up upon. When developing prototypes I have found it most effective to focus on getting something useable to test out ideas. However, even when still in a prototyping phase building upon quick and dirty solutions becomes unmanageable.</p>
                <p>At this point in our project we have a clear idea on the future direction for our final product. I think it is important to consider the architecture of the software initially.</p>
                <p>I have previously made smaller games in the past and as they grew larger and more complicated the more difficult I found it to add features, make improvements and expand the software.</p>
                <p>As a group we found it difficult to initially design the structure of our program. I think this was partly due to our inexperience, partly due to the uncertainty of the final product and also due to the inherent difficulty of software architecture.</p>
                <p>In the course Software Development and Design (COMP2130) concepts such as cohesion, coupling and meddling were useful for this stage of our group project. However, I feel as though there isn’t a silver bullet when it comes to software design. Each different piece of software is different and naturally will need to be designed differently. It would be unreasonable to design our game in the same way that NASA would design the software running on a space probe.</p>
                <p>Central to the design of the game is an Entity Component Systems (ECS). The core concept of this design pattern is to build the software in a composition way rather than a more traditional object oriented heretical method. This design pattern is used frequently within industry however, I think it is also important to still consider the limitations of our project. Given that there are four programmers working for two semesters, the scope of what can be achieved is limited.</p>
                <p>One difficulty I have found as working on as part of a team on moderately sized software is that of communication. Team meeting are extremely helpful in ensuring that we all understand where we are up to and where we are heading. However, I have found ensuring that all team members understand all parts of the code more difficult. To completely understand each team members code and how it fits into the greater scope of the game becomes more difficult as the project progresses.</p>
                <P>Well written, elegant and adequately commented code helps to address this. Also informal code reviews to see what changes other team members have made has been beneficial. I find reviewing another team members code helps in both understanding how it works but also personally, I may learn something or be able to find bugs or things that could be improved. Furthermore, talking through the code as a team or in partners I have found overall very productive.</p>
                <p>Although, it is often not important to fully understand each component of the program. For example, it has been my responsibility to handle the rendering and how images and text is drawn to the window. I have attempted to make the API to use the renderer as simple as possible to use so other team members can easily use it for their separate parts. In this way, through our meetings I can explain in broad terms how the renderer works and how to use it. Other team members will still be able to use it without concerning themselves on it’s intricacies, and if improvements need to be made they would fall under my responsibility.</p>
                <p>A issue we faced as a team was how to efficiently delegate work without getting in the way of each other. For example I might work on a particular feature simultaneously as another teammate but when merging the changes together our changes would be too incompatible to be effectively merged. In situations such as this we would manually work through, line by line what needed to be added.</p>
                <p>To minimise the occurrence of this problem and to be able to easily merge together changes while all working on the project required us to make some changes. Firstly I found it important that each team member is working on systems as isolated as possible. Secondly, by frequently merging our changes to the master branch we could ensure no ones changes were left too far behind. Also important is to communicate to each other what we are working on and which files we were modifying. Lastly, due to the fact that we are not working on the project full time, one person could make drastic changes to the project and once done, other team members can continue working.</p>
                <iframe width="560" height="315" src="https://www.youtube.com/embed/mNdBZDsU9nI" frameborder="0" allowfullscreen></iframe>
            </div>
        </div>
    </body>
</html>